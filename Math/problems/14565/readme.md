사용 알고리즘 : 확장 유클리드 알고리즘(Extended Euclidean Algorithm)

일단, 이 문제와, 확장 유클리드 알고리즘에 대해서 이해하려면, **모듈러 계(Modular arithmetic)** 에 대해 이해해야 한다. 

일단, 모듈러 계는, 무한을 다룰 수 없는 컴퓨터상에서 무한을 다룰 수 있게 해 주는 것이다. 일상의 대표적인 예시는 아날로그 시계가 있다. 시계는 분명 숫자가 1~12까지밖에 없는데 어떻게 무한하고 연속적인 흐름의 "시간"을 표현할 수 있는 것일까?

우리는 밖을 보니 어둡고, 만약 시계가 11을 가리킨다면, 아침 11시가 아닌, 밤 11시라고 생각할 수 있다. 

모듈러 계도 이와 비슷하게 무한(혹은 진짜 ㅈㄴ 큰 수) 를 처리하는데, 우리가 프로그래밍을 하다가 만나는 integer overflow 도, int자료형(32bit)이 2^32 모듈러 계로 동작하기 때문에 나타나는 것이다. 

 **N의 모듈러 계** 에서는, 모든 숫자는 **0~N-1** 사이의 수로 대응된다. **어떤 수를 N으로 나눈 나머지** 를 취한다고 생각하면 된다. 그러면, 당연히 무한을 표현할 수 있다. 

x를, y의 모듈러 계 위에서는, **x mod y** 와 같이 표현한다. **x mod y = x % y** 이다. 

모듈러 계 상에서도 사칙연산을 정의할 수 있다. 

1. 덧셈 

(x + y) mod m = (x mod m + y mod m) mod m

2. 뺄셈
   
(x - y) mod m = (x mod m - y mod m) mod m

3. 곱셉

(x * y) mod m = (x mod m * y mod m) mod m

하지만, 나눗셈은 (x / y) mod m = (x mod m / y mod m) mod m 로 **정의되지 않는다**. 

모듈레 계에서 나눗셈을 수행하려면, **모듈러 곱셈 역원(Modular Inverse)** 을 곱하면 된다. 

**xa mod m = 1** 인 경우, **a를 inverse of x modulo m** 이라고 한다. 

제출 코드는, 0ms, 2020kb에 AC를 받는다. 

제출 기록 : https://www.acmicpc.net/status?from_mine=1&problem_id=14565&user_id=dlrkddnr2718

그러면, 이를 이용해, 어떻게 나눗셈을 수행할 수 있을까?

-> 곱셉에 대한 모듈로 연산은 정의되어 있었고, 이제 x로 나눈다 라는 말은, **invese of x modulo m** 을 곱하라 라는 말과 동치이다. 

